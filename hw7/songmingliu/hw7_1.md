
using Graphs
using SparseArrays
using LinearAlgebra
using Plots
using Random
using Printf

println("=== HW7 Task 1: Ground State Energy of Anti-ferromagnetic Ising Model ===")

"""
Construct a unit disk graph from coordinates
Points within distance `radius` are connected
"""
function UnitDiskGraph(coordinates::Vector{NTuple{3,Float64}}, radius::Float64)
    n = length(coordinates)
    g = SimpleGraph(n)

    for i in 1:n
        for j in (i+1):n
            dist = sqrt(sum((coordinates[i][k] - coordinates[j][k])^2 for k in 1:3))
            if dist <= radius + 1e-10  # small tolerance for numerical errors
                add_edge!(g, i, j)
            end
        end
    end

    return g
end

"""
Construct the fullerene graph in 3D space
"""
function fullerene()
    th = (1 + sqrt(5)) / 2
    res = NTuple{3,Float64}[]
    for (x, y, z) in ((0.0, 1.0, 3th), (1.0, 2 + th, 2th), (th, 2.0, 2th + 1.0))
        for (a, b, c) in ((x, y, z), (y, z, x), (z, x, y))
            for loc in ((a, b, c), (a, b, -c), (a, -b, c), (a, -b, -c), 
                       (-a, b, c), (-a, b, -c), (-a, -b, c), (-a, -b, -c))
                if loc ∉ res
                    push!(res, loc)
                end
            end
        end
    end
    return res
end

"""
Calculate energy of the anti-ferromagnetic Ising model
H = Σ_{ij ∈ E} σ_i σ_j
"""
function ising_energy(graph::SimpleGraph, spins::Vector{Int})
    energy = 0
    for edge in edges(graph)
        i, j = src(edge), dst(edge)
        energy += spins[i] * spins[j]
    end
    return energy
end

"""
Delta energy when flipping spin at vertex v
"""
function deltaE(graph::SimpleGraph, spins::Vector{Int}, v::Int)
    sv = spins[v]
    dE = 0
    for u in neighbors(graph, v)
        dE += -2 * sv * spins[u]
    end
    return dE
end

"""
Simulated Annealing Algorithm for Problem 1
"""
function simulated_annealing(
    graph::SimpleGraph;
    T_init::Float64=10.0,
    T_final::Float64=0.01,
    cooling_rate::Float64=0.95,
    steps_per_temp::Int=1000,
    n_runs::Int=10
)
    n = nv(graph)
    best_energy = Inf
    best_spins = nothing

    for run in 1:n_runs
        # Initialize random spins
        spins = rand([-1, 1], n)
        current_energy = ising_energy(graph, spins)

        T = T_init

        while T > T_final
            for _ in 1:steps_per_temp
                i = rand(1:n)
                ΔE = deltaE(graph, spins, i)

                if ΔE < 0 || rand() < exp(-ΔE / T)
                    spins[i] *= -1
                    current_energy += ΔE
                end
            end
            T *= cooling_rate
        end

        # Verify and update best solution
        final_energy = ising_energy(graph, spins)
        if final_energy < best_energy
            best_energy = final_energy
            best_spins = copy(spins)
        end

        println("  Run $run: Energy = $final_energy")
    end

    return best_energy, best_spins
end


"""
Solve Problem 1: Ground state energy of Fullerene graph
"""
function solve_problem1()
    println("\n" * "=" ^ 70)
    println("PROBLEM 1: Ground State Energy of Fullerene Graph")
    println("=" ^ 70)

    # Construct the fullerene graph
    fullerene_coords = fullerene()
    fullerene_graph = UnitDiskGraph(fullerene_coords, sqrt(5))

    println("Fullerene graph: $(nv(fullerene_graph)) vertices, $(ne(fullerene_graph)) edges")
    
    # Solve using simulated annealing
    println("\nRunning Simulated Annealing...")
    
    best_energy, best_spins = simulated_annealing(
        fullerene_graph,
        T_init=20.0,
        T_final=0.001,
        cooling_rate=0.98,
        steps_per_temp=3000,
        n_runs=30
    )

    println("\n✅ Ground State Energy: $best_energy")
    verify_energy = ising_energy(fullerene_graph, best_spins)
    println("   Verified: $verify_energy")

    # Analyze spin distribution
    n_up = count(s -> s == 1, best_spins)
    n_down = count(s -> s == -1, best_spins)
    println("   Spin distribution: ↑=$n_up, ↓=$n_down")

    # Optional: Visualize the result
    println("\nOptional: You can visualize the result by plotting the graph with spins colored differently")
    println("For visualization, you would need to use a package like GraphPlot or Makie")

    return best_energy, best_spins, fullerene_graph
end

println("Starting Task 1...")
best_energy, best_spins, fullerene_graph = solve_problem1()

println("\nTask 1 completed successfully!")
println("The ground state energy of the anti-ferromagnetic Ising model on the Fullerene graph is $best_energy.")

