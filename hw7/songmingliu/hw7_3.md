# Homework 7 - Task 3: Parallel Tempering for Spin Glass

using Graphs
using SparseArrays
using LinearAlgebra
using Random
using Printf

println("=== HW7 Task 3: Parallel Tempering for Spin Glass ===")

"""
Strong product of two graphs
"""
function strong_product(g1, g2)
    vs = [(v1, v2) for v1 in vertices(g1), v2 in vertices(g2)]
    graph = SimpleGraph(length(vs))
    for (i, vi) in enumerate(vs), (j, vj) in enumerate(vs)
        if (vi[1] == vj[1] && has_edge(g2, vi[2], vj[2])) ||
                (vi[2] == vj[2] && has_edge(g1, vi[1], vj[1])) ||
                (has_edge(g1, vi[1], vj[1]) && has_edge(g2, vi[2], vj[2]))
            add_edge!(graph, i, j)
        end
    end
    return graph
end

"""
Strong power of a graph
"""
strong_power(g, k::Int) = k == 1 ? g : strong_product(g, strong_power(g, k - 1))

"""
Spin glass structure
"""
struct SpinGlass
    graph::SimpleGraph
    J::Vector{Int}  # coupling
    h::Vector{Int}  # bias
end

"""
Create spin glass problem on cycle graph
"""
function spin_glass_c(n::Int, k::Int)
    g1 = Graphs.cycle_graph(n)
    g = strong_power(g1, k)
    coupling = fill(1, ne(g))
    bias = 1 .- degree(g)
    return SpinGlass(g, coupling, bias)
end

"""
Calculate energy of a spin configuration for SpinGlass problem
"""
function energy(sg::SpinGlass, spins::Vector{Int})
    E = 0
    for (idx, edge) in enumerate(edges(sg.graph))
        i, j = src(edge), dst(edge)
        E += sg.J[idx] * spins[i] * spins[j]
    end
    for i in 1:length(spins)
        E += sg.h[i] * spins[i]
    end
    return E
end

"""
Parallel Tempering (Replica Exchange Monte Carlo) Algorithm
"""
function parallel_tempering(
    sg::SpinGlass;
    n_replicas::Int=16,
    T_min::Float64=0.01,
    T_max::Float64=5.0,
    n_sweeps::Int=10000,
    exchange_interval::Int=10,
    thermalization::Int=1000,
    show_progress::Bool=true,
    progress_name::String="PT",
    temperature_schedule::Symbol=:beta_power,
    schedule_gamma::Float64=2.0
)
    n = nv(sg.graph)

    # Precompute neighbor lists and edge indices for fast ΔE updates
    edges_vec = collect(edges(sg.graph))
    edge_index = Dict{Tuple{Int,Int},Int}()
    for (idx, e) in enumerate(edges_vec)
        i, j = src(e), dst(e)
        edge_index[(min(i,j), max(i,j))] = idx
    end
    neighbors_list = Vector{Vector{Int}}(undef, n)
    neighbor_edge_indices = Vector{Vector{Int}}(undef, n)
    for i in 1:n
        nbs = collect(neighbors(sg.graph, i))
        neighbors_list[i] = nbs
        neighbor_edge_indices[i] = [edge_index[(min(i,nb), max(i,nb))] for nb in nbs]
    end

    # Temperature ladder generator (densify near low T by default)
    function make_temperatures(Tmin::Float64, Tmax::Float64, R::Int, schedule::Symbol, gamma::Float64)
        if R < 2
            return [Tmax]
        end
        if schedule === :geometric
            return [Tmax * (Tmin / Tmax)^(i / (R - 1)) for i in 0:(R - 1)]
        elseif schedule === :beta_linear
            βmin = 1.0 / Tmax
            βmax = 1.0 / Tmin
            βs = [βmin + (βmax - βmin) * (i / (R - 1)) for i in 0:(R - 1)]
            return [1.0 / β for β in βs]
        else # :beta_power
            βmin = 1.0 / Tmax
            βmax = 1.0 / Tmin
            βs = [βmin + (βmax - βmin) * ((i / (R - 1))^gamma) for i in 0:(R - 1)]
            return [1.0 / β for β in βs]
        end
    end
    temperatures = make_temperatures(T_min, T_max, n_replicas, temperature_schedule, schedule_gamma)

    # Seed a few replicas with structured initial states for better coverage
    replicas = Vector{Vector{Int}}(undef, n_replicas)
    replicas[1] = fill(-1, n)
    if n_replicas >= 2
        replicas[2] = fill(1, n)
    end
    if n_replicas >= 3
        # Align with local fields: s_i = -sign(h_i) (treat 0 as +1)
        replicas[3] = [sg.h[i] <= 0 ? 1 : -1 for i in 1:n]
    end
    for r in 4:n_replicas
        replicas[r] = rand([-1, 1], n)
    end
    energies = [energy(sg, replica) for replica in replicas]

    best_energy = minimum(energies)
    best_spins = copy(replicas[argmin(energies)])

    n_accepted = zeros(Int, n_replicas)
    n_exchanges = zeros(Int, n_replicas - 1)
    n_exchange_attempts = zeros(Int, n_replicas - 1)

    # progress helper
    function bar(p::Float64; width::Int=40)
        k = clamp(Int(round(p * width)), 0, width)
        return "[" * repeat("=", k) * repeat(" ", width - k) * "]"
    end
    next_tick = 1
    tick_every = max(1, Int(ceil(n_sweeps / 100)))  # ~100 updates

    for sweep in 1:n_sweeps
        for r in 1:n_replicas
            T = temperatures[r]

            # Random-order sweep: consider each spin once per sweep in random order
            for i in randperm(n)

                ΔE = 0.0
                nbs = neighbors_list[i]
                eidxs = neighbor_edge_indices[i]
                @inbounds for k in eachindex(nbs)
                    nb = nbs[k]
                    edge_idx = eidxs[k]
                    ΔE -= 2 * sg.J[edge_idx] * replicas[r][i] * replicas[r][nb]
                end
                ΔE -= 2 * sg.h[i] * replicas[r][i]

                if ΔE < 0 || rand() < exp(-ΔE / T)
                    replicas[r][i] *= -1
                    energies[r] += ΔE
                    n_accepted[r] += 1
                end
            end
        end

        if sweep % exchange_interval == 0
            for r in 1:(n_replicas-1)
                T1, T2 = temperatures[r], temperatures[r+1]
                E1, E2 = energies[r], energies[r+1]

                # ΔE is the log Metropolis ratio for the swap up to sign:
                # ΔE = (E2 - E1) * (β1 - β2), where β = 1/T.
                # Acceptance: min(1, exp(-ΔE))
                ΔE = (E2 - E1) * (1/T1 - 1/T2)

                n_exchange_attempts[r] += 1

                if ΔE <= 0 || rand() < exp(-ΔE)
                    replicas[r], replicas[r+1] = replicas[r+1], replicas[r]
                    energies[r], energies[r+1] = energies[r+1], energies[r]
                    n_exchanges[r] += 1
                end
            end
        end

        if sweep > thermalization
            min_idx = argmin(energies)
            if energies[min_idx] < best_energy
                best_energy = energies[min_idx]
                best_spins = copy(replicas[min_idx])
            end
        end

        if show_progress && sweep >= next_tick
            p = sweep / n_sweeps
            attempted_flips = n_replicas * sweep * n
            acc_rate = attempted_flips > 0 ? sum(n_accepted) / attempted_flips : 0.0
            exch_rate = sum(n_exchange_attempts) > 0 ? sum(n_exchanges) / sum(n_exchange_attempts) : 0.0
            println("  $progress_name ", bar(p), @sprintf(" %6.2f%% ", p*100),
                    "Best=", best_energy, 
                    " Min=", minimum(energies),
                    " Acc=", @sprintf("%.3f", acc_rate),
                    " Exch=", @sprintf("%.3f", exch_rate),
                    " Sweep=", sweep, "/", n_sweeps)
            flush(stdout)
            next_tick += tick_every
        end
    end

    return best_spins, best_energy
end

"""
Greedy quench: deterministically flip any spin that lowers the energy.
Runs up to `max_passes` full passes or until no improvement.
"""
function greedy_quench!(sg::SpinGlass, spins::Vector{Int}; max_passes::Int=2)
    n = length(spins)
    # Precompute neighbor lists and edge indices
    edges_vec = collect(edges(sg.graph))
    edge_index = Dict{Tuple{Int,Int},Int}()
    for (idx, e) in enumerate(edges_vec)
        i, j = src(e), dst(e)
        edge_index[(min(i,j), max(i,j))] = idx
    end
    neighbors_list = Vector{Vector{Int}}(undef, n)
    neighbor_edge_indices = Vector{Vector{Int}}(undef, n)
    for i in 1:n
        nbs = collect(neighbors(sg.graph, i))
        neighbors_list[i] = nbs
        neighbor_edge_indices[i] = [edge_index[(min(i,nb), max(i,nb))] for nb in nbs]
    end

    E = energy(sg, spins)
    for _ in 1:max_passes
        improved = false
        for i in 1:n
            ΔE = 0.0
            nbs = neighbors_list[i]
            eidxs = neighbor_edge_indices[i]
            @inbounds for k in eachindex(nbs)
                nb = nbs[k]
                edge_idx = eidxs[k]
                ΔE -= 2 * sg.J[edge_idx] * spins[i] * spins[nb]
            end
            ΔE -= 2 * sg.h[i] * spins[i]
            if ΔE < 0
                spins[i] *= -1
                E += ΔE
                improved = true
            end
        end
        if !improved
            break
        end
    end
    return E
end

"""
My ground state solver using parallel tempering
"""
function my_ground_state_solver(sg::SpinGlass; show_progress::Bool=true, progress_name::String="PT")
    n = nv(sg.graph)
    println("  Vertices: $n, Edges: $(ne(sg.graph))")

    if n <= 100
        # For smaller problems, use fewer replicas and sweeps
        n_replicas = 8
        n_sweeps = 5000
        T_max = 3.0
        n_runs = 3
    else
        # For larger problems
        n_replicas = 16
        n_sweeps = 10000
        T_max = 5.0
        n_runs = 5
    end

    best_solution = nothing
    best_energy = Inf

    for run in 1:n_runs
        println("\n  --- Run $run/$n_runs ---")

        spins, E = parallel_tempering(
            sg,
            n_replicas=n_replicas,
            T_min=0.001,
            T_max=T_max,
            n_sweeps=n_sweeps,
            exchange_interval=10,
            thermalization=n_sweeps ÷ 5,
            show_progress=show_progress,
            progress_name=progress_name,
            temperature_schedule=:beta_power,
            schedule_gamma=2.0
        )

        # Apply greedy quench to refine the solution
        E = greedy_quench!(sg, spins; max_passes=5)

        # Update best solution
        if E < best_energy
            best_energy = E
            best_solution = copy(spins)
            println("  ★ NEW BEST: $best_energy")
        end

        println("  Run $run Energy: $E")
    end

    println("\n  ✅ FINAL BEST ENERGY: $best_energy")

    return best_solution
end


"""
Solve Problem 3: Spin glass with parallel tempering
"""
function solve_problem3()
    println("\n" * "=" ^ 70)
    println("PROBLEM 3: Parallel Tempering for Spin Glass (Challenge)")
    println("=" ^ 70)

    # Test case 1
    println("\n--- Test Case 1: spin_glass_c(5, 2) ---")
    sg1 = spin_glass_c(5, 2)
    solution1 = my_ground_state_solver(sg1)
    energy1 = energy(sg1, solution1)
    println("\n✅ Test 1 Energy: $energy1 (Expected: -85)")
    test1_pass = energy1 == -85
    println("   Test 1: ", test1_pass ? "PASSED ✓" : "FAILED ✗")

    # Test case 2
    println("\n--- Test Case 2: spin_glass_c(7, 4) ---")
    println("⚠️  This may take a long time...")
    sg2 = spin_glass_c(7, 4)
    solution2 = my_ground_state_solver(sg2)
    energy2 = energy(sg2, solution2)
    println("\n✅ Test 2 Energy: $energy2 (Expected: < -93855)")
    test2_pass = energy2 < -93855
    println("   Test 2: ", test2_pass ? "PASSED ✓" : "FAILED ✗")

    return energy1, energy2, test1_pass, test2_pass
end

println("Starting Task 3...")
energy1, energy2, test1_pass, test2_pass = solve_problem3()

println("\nTask 3 completed successfully!")
println("The parallel tempering algorithm was implemented and tested on spin glass problems.")
println("Results:")
println("  Test 1 (5,2): Energy = $energy1, Passed = $test1_pass")
println("  Test 2 (7,4): Energy = $energy2, Passed = $test2_pass")