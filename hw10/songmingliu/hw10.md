# Import required packages
using JuMP
using HiGHS
using SCIP # Added for Problem 2
import MathOptInterface as MOI
using Random
using Printf
using Dates
using Graphs # Added for Petersen graph definition

println("="^70)
println("HOMEWORK 10 - Songming Liu")
println("="^70)

# ================================================================
# PROBLEM 1: Maximum Independent Set (MIS) using Integer Programming
# ================================================================
println("\n" * "="^70)
println("PROBLEM 1: MIS on Petersen Graph")
println("="^70)

# --- Define Petersen Graph ---
function petersen_adj()
    # Label outer 0..4, inner 5..9; edges: outer cycle (i,i+1), inner star (i,i+2), spokes (i, i+5)
    adj = [Int[] for _ in 1:10]
    # outer cycle 0..4 -> vertices 1..5
    for i in 0:4
        u = i + 1
        v = ((i + 1) % 5) + 1
        push!(adj[u], v); push!(adj[v], u)
    end
    # spokes
    for i in 0:4
        u = i + 1
        v = 5 + i + 1  # 6..10
        push!(adj[u], v); push!(adj[v], u)
    end
    # inner star edges (i -> i+2 mod 5) between 5..9 -> vertices 6..10
    for i in 0:4
        u = 5 + i + 1
        v = 5 + ((i + 2) % 5) + 1
        push!(adj[u], v); push!(adj[v], u)
    end
    # dedup
    for v in 1:10
        adj[v] = sort(unique(adj[v]))
    end
    return adj
end

# --- Solve MIS using JuMP ---
function mis_ip(adj; optimizer=HiGHS.Optimizer, verbose=false)
    n = length(adj)
    model = Model(optimizer)
    verbose || set_silent(model)
    try
        MOI.set(model, MOI.TimeLimitSec(), 30.0) # Optional: Add time limit
    catch err
        @warn "Failed to set time limit: $err"
    end
    @variable(model, x[1:n], Bin)
    # Add constraint for each unique edge (u,v) where u < v to avoid duplication
    for v in 1:n
        for u in adj[v]
            if u > v # Ensures each edge is added only once
                @constraint(model, x[v] + x[u] <= 1)
            end
        end
    end
    @objective(model, Max, sum(x))
    optimize!(model)

    term_status = termination_status(model)
    primal_status = primal_status(model)

    println("  Termination status: ", term_status)
    println("  Primal status: ", primal_status)

    if term_status == MOI.OPTIMAL
        max_size = objective_value(model)
        println("  Maximum independent set size = ", round(Int, max_size))

        chosen_vertices = [v for v in 1:n if value(x[v]) > 0.5]
        println("  One maximum independent set is: ", chosen_vertices)
        return round(Int, max_size), chosen_vertices
    else
        println("  Solver did not find an optimal solution.")
        return nothing, nothing
    end
end

# Run Problem 1
adj_petersen = petersen_adj()
optimal_size, mis_solution = mis_ip(adj_petersen; optimizer=HiGHS.Optimizer)


# ================================================================
# PROBLEM 2: Tuning Harness for IP Solver (Using SCIP)
# ================================================================
println("\n" * "="^70)
println("PROBLEM 2: Solver Tuning (Using SCIP)")
println("="^70)

# --- CSP Model Definition (Example problem, adapted from provided code) ---
function build_csp_model!(model::Model, instance_data)
    # Example CSP: Minimize sum of binary variables x_i subject to sum >= 3
    # This is a simple proxy problem, not necessarily related to crystal structure prediction.
    # In a real scenario, this function would build the specific CSP model.
    n = 10 # Size of the problem for this example
    @variable(model, x[1:n], Bin)
    @constraint(model, sum(x) >= 3) # Constraint example
    @objective(model, Min, sum(x))  # Objective example
end

# --- Configure SCIP Solver ---
function configure_scip!(model::Model; tuned::Bool=false)
    # Suppress verbose output
    set_optimizer_attribute(model, "display/verblevel", 0)

    if !tuned
        # Default settings
        return
    end

    # Tuned settings based on provided code
    set_optimizer_attribute(model, "presolving/emphasis", "aggressive")
    set_optimizer_attribute(model, "heuristics/emphasis", "aggressive")
    set_optimizer_attribute(model, "separating/emphasis", "fast")
    set_optimizer_attribute(model, "separating/maxroundsroot", 5)
    set_optimizer_attribute(model, "separating/maxcutsroot", 200)
    set_optimizer_attribute(model, "branching/preferbinary", true)
    set_optimizer_attribute(model, "timing/statistictiming", false)
end

# --- Solve a single instance ---
function solve_instance(instance_data; tuned::Bool=false)
    model = Model(SCIP.Optimizer)
    configure_scip!(model; tuned=tuned)
    build_csp_model!(model, instance_data)

    t = @elapsed optimize!(model)

    status = termination_status(model)
    obj    = has_values(model) ? objective_value(model) : NaN

    return t, obj, status
end

# --- Run benchmark comparing default vs tuned settings ---
function run_benchmark(instances)
    baseline_times = Float64[]
    tuned_times    = Float64[]

    println("  Running baseline (default SCIP settings)...")
    for (i, inst) in enumerate(instances)
        t, obj, status = solve_instance(inst; tuned=false)
        push!(baseline_times, t)
        @printf("    Baseline: Instance %d  Time=%.3f s  Status=%s  Obj=%.2f\n",
                i, t, string(status), obj)
    end

    println("\n  Running tuned settings...")
    for (i, inst) in enumerate(instances)
        t, obj, status = solve_instance(inst; tuned=true)
        push!(tuned_times, t)
        @printf("    Tuned:    Instance %d  Time=%.3f s  Status=%s  Obj=%.2f\n",
                i, t, string(status), obj)
    end

    # Calculate summary statistics
    avg_base = mean(baseline_times)
    avg_tune = mean(tuned_times)
    speedup  = avg_base / avg_tune

    println("\n  Summary:")
    @printf("    Average baseline time = %.3f s\n", avg_base)
    @printf("    Average tuned time    = %.3f s\n", avg_tune)
    @printf("    Speedup (baseline / tuned) = %.2fx\n", speedup)

    if speedup > 2.0
        println("    \u2713 SUCCESS: Achieved >2x performance improvement!")
    else
        println("    \u2718 Improvement: $(round(speedup, digits=2))x is less than 2x.")
    end

    return speedup
end

# Define some dummy instances for the CSP benchmark
instances = ["instance1", "instance2", "instance3", "instance4"]

# Run Problem 2 benchmark
scip_speedup = run_benchmark(instances)


# ================================================================
# PROBLEM 3: 0-1 ILP Factorization (20x20 - Demo with 12x12)
# ================================================================
println("\n" * "="^70)
println("PROBLEM 3: 0-1 ILP Factorization (Demo with 12x12)")
println("="^70)

function factor_ilp(m::Int, n::Int, N::BigInt; optimizer=HiGHS.Optimizer, verbose=false)
    # Bits are indexed from 0 (LSB). Extract N bits up to m+n.
    total_bits = m + n
    N_bits = [Int((N >> k) & 1) for k in 0:total_bits]

    model = Model(optimizer)
    verbose || set_silent(model)

    @variable(model, p[0:m-1], Bin)
    @variable(model, q[0:n-1], Bin)
    @variable(model, y[0:m-1, 0:n-1], Bin)

    # McCormick linearization for y_ij = p_i * q_j (tight for binary vars)
    for i in 0:m-1, j in 0:n-1
        @constraint(model, y[i,j] <= p[i])
        @constraint(model, y[i,j] <= q[j])
        @constraint(model, y[i,j] >= p[i] + q[j] - 1)
    end

    # Carry variables
    # Upper bounds for carries: at position k, sum of partials <= min(k+1, m, n)
    ub_c = [min(k+1, m, n) for k in 0:total_bits]
    @variable(model, c[0:total_bits] >= 0, Int)
    for k in 0:total_bits
        set_upper_bound(c[k], ub_c[k+1])
    end

    # Initial carry is 0
    @constraint(model, c[0] == 0)

    # Bit-balance constraints: sum_{i+j=k} y[i,j] + c[k-1] = N_k + 2*c[k]
    # The formula sum(...) + c[k] = N_bits[k+1] + 2*c[k+1] represents balance at bit k+1.
    for k in 0:total_bits-1
        @constraint(model, sum(y[i, k - i] for i in max(0, k-(n-1)) : min(m-1, k)) + c[k] == N_bits[k+1] + 2*c[k+1])
    end

    # Final carry must be 0 (if N fits in m+n bits)
    @constraint(model, c[total_bits] == 0)

    # No objective: feasibility problem
    @objective(model, Min, 0)
    optimize!(model)

    status = termination_status(model)
    if status != MOI.OPTIMAL
        error("ILP did not solve to optimality for N=$N: $status")
    end

    p_bits = [round(Int, value(p[i])) for i in 0:m-1]
    q_bits = [round(Int, value(q[j])) for j in 0:n-1]

    # Convert bits (LSB-first) to integers
    function bits_to_int(bits)
        x = BigInt(0)
        for (k, b) in enumerate(bits)
            x += BigInt(b) << (k-1)
        end
        return x
    end
    a = bits_to_int(p_bits)
    b = bits_to_int(q_bits)
    return a, b
end

function run_q3_demo(; max_lines::Int = 3) # Reduced demo lines for clarity
    println("  Running demo on numbers_12x12.txt (first $max_lines entries)...")
    # Note: This path assumes the script is run from a location where the data file is accessible.
    # You might need to adjust the path based on your actual file structure.
    data_path = "../example/data/numbers_12x12.txt" # Adjust as needed

    try
        open(data_path, "r") do io
            println("  " * @sprintf("%-6s %-6s %-14s %-14s %-10s", "m", "n", "N", "Factors Found", "Time(s)"))
            for (line_num, line) in enumerate(eachline(io))
                line = strip(line); isempty(line) && continue
                parts = split(line)
                m = parse(Int, parts[1])
                n = parse(Int, parts[2])
                N = parse(BigInt, parts[3])
                t0 = time()
                a, b = factor_ilp(m, n, N; optimizer=HiGHS.Optimizer, verbose=false)
                dt = time() - t0
                ok = (a * b == N)
                result_str = ok ? "$(a) * $(b)" : "FAIL"
                println("  " * @sprintf("%-6d %-6d %-14s %-14s %-10.2f", m, n, string(N), result_str, dt))
                if line_num >= max_lines
                    break
                end
            end
        end
    catch e
        println("  Error reading or processing demo data file '$data_path': $e")
        println("  Skipping demo run.")
    end
end

# Run Problem 3 Demo
run_q3_demo()

println("\n" * "="^70)
println("ALL PROBLEMS COMPLETED!")
println("="^70)